import jenkins.model.*

def stepsForParallel = [:]

// Since this method uses grep/collect it needs to be annotated with @NonCPS
// It returns a simple string map so the workflow can be serialized
@NonCPS
def jobs(jobRegexp) {
    Jenkins.instance.getAllItems()
        .grep { it.name ==~ ~"${jobRegexp}"  }
        .collect { [ name : it.name.toString(),
                     fullName : it.fullName.toString() ] }
}

j = jobs('build-(backend|frontend)-(multibranch)')
for (int i=0; i < j.size(); i++) {
    stepsForParallel["${j[i].name}"] = transformIntoStep(j[i].fullName)
}

parallel stepsForParallel

def transformIntoStep(jobFullName) {
    // We need to wrap what we return in a Groovy closure, or else it's invoked
    // when this method is called, not when we pass it to parallel.
    // To do this, you need to wrap the code below in { }, and either return
    // that explicitly, or use { -> } syntax.
    return {
        // Job parameters can be added to this step
        build jobFullName
    }
}

//pipeline {
//    agent any
//    stages {
//        stage ('Build App') {
//            parallel {
//                stage ('Build Frontend') {
//                    steps {
//                        build([
//                            job       : 'build-frontend-multibranch',
//                            wait      : false,
//                        ])
//                    }
//                }
//                stage ('Build Backend') {
//                    steps {
//                        build([
//                            job       : 'build-backend-multibranch',
//                            wait      : false
//                        ])
//                    }
//                }
//            }
//        }
//    }
//}
//
